# Protocol Rule Processor Diamond Structure 

## Purpose

The Rule Processor Diamond is a proxy contract that is used by application contracts to assess economic actions against rules that are active within that handler. The Rule Processor will delegate those calls to the appropriate facet contract, allowing for efficient on chain rule assessments per transaction. The Rule Processor Diamond proxy also acts as a single source address for the creation of rules for application contracts. [Rule administrators](../permissions/ADMIN-ROLES.md) of an application are allowed to add rules to the Rule Processor storage. These rules are immutable once created and can be shared across different applications with the rule id number generated by the protocol. 

A diamond pattern allows the protocol to upgrade, add new features and improvements through the use of a proxy contract. New facet contracts can be deployed and connected to the diamond via a specialized function called facetCut. New rules and improvements allow the protocol to grow while maintaining address immutability with the proxy contract. Application manager and handler contracts will only need to set the address of the diamond proxy at deployment, without having to worry about that address changing overtime.  
#### *[ERC 2535: Diamond Proxies](https://eips.ethereum.org/EIPS/eip-2535)*

The Rule Processor diamond architecture consists of the Rule Processor Diamond, [Rule Processor Diamond Libraries](./RULE-PROCESSOR-LIBRARIES.md) and supporting [Rule Processor Facet](./RULE-PROCESSOR-FACETS.md) contracts. The library contracts hosur supporting functions for upgrading the diamond, connecting new facets, validating rule existence and supporting rule checks. The individual facet contracts work as both storage contracts for rules as well as rule check functions to validate transactions on chain with the paramters of the rules created and stored within the protocol. 

#### *[see diamond diagram](../images/ProtocolOverview.png)*

## Functions 

The Rule Processor Diamond contains one primary function, the fallback function. This will find the function selector being passed to the diamond by a calling contract. When a valid function selector is passed to the Rule Processor Diamond proxy, this contract will pass all the callData to the relevent facet in order to add a new rule or validate a transaction. 

```c
 /**
    * @dev Function finds facet for function that is called and execute the function if a facet is found and return any value.
*/
    fallback() external payable {
        RuleProcessorDiamondStorage storage ds;
        bytes32 position = DiamondLib.DIAMOND_CUT_STORAGE;
        assembly {
            ds.slot := position
        }
        address facet = ds.facetAddressAndSelectorPosition[msg.sig].facetAddress;
        if (facet == address(0)) {
            revert FunctionNotFound(msg.sig);
        }
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }
```

## Constructor  

The Rule Processor Diamond constructor is an essential part of the diamond pattern. The constructor calls the diamondCut function and stores the addresses and function selectors of all deployed facets passed to the constructor. 

This function is run only once at deployment and connects the diamond proxy to the facets that are already deployed. New facets may be connected to the diamond post deployment. 

```c
constructor(FacetCut[] memory diamondCut, RuleProcessorDiamondArgs memory args) payable {
        DiamondLib.diamondCut(diamondCut, args.init, args.initCalldata);
    }
```

## Data Structures 

```c
/**
 * This is used in diamond constructor
 * more arguments are added to this struct
 * this avoids stack too deep errors
 */
struct RuleProcessorDiamondArgs {
    address init;
    bytes initCalldata;
}
```

## Errors 
The rule processor will revert with the following error if the function selector is not found in storage: 

```
error FunctionNotFound(bytes4 _functionSelector);
```

The selector for this error is `0xd6009a50`.


## Upgrading 
Facets may be added or removed over time. [Rule Processor Facets](./RULE-PROCESSOR-FACETS.md) contains the process for upgrading facets. 